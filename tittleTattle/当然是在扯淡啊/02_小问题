1， == 和hashcode
    ==是比较的对象的内存地址。所以有时候就需要equals来进行比较。而hashcode则相当于对象的一个签名。

2， hashmap的底层
    数组（hash桶）加链表。
    transient HashMap.Node<K, V>[] table     +          Node<K,V> next;
    hashmap产生的死锁线程不安全问题？  多条线程并发时候，在resize的时候，会发生链表互相指向死锁的情况。
    但是在jdk8中采用了红黑树解决了这个问题。
    jdk8对hashmap的优化： 当链表的长度大于8的时候，就会转链表为红黑树。红黑树当然不会发生链表的循环引用情况。
    并且，红黑树的get（）方法的时间复杂度是O(log n),,远远小于链表的O(n).

    既然是数组+链表,get方法怎么在链表中取到你要的那个对象！
    答：链表是Entry链表。其中每个Entry有key，value，hash，next。 遍历链表，对hash key做==操作，判断是否是你要的那个。

3， concurrenthashmap的原理
    jdk1.7是segment分段锁，将hashmap的大数组，分为一个个的小数组。然后每个分段用reentrantlock锁。
    jdk1.8，放弃了segment，采用数组+链表+红黑树。
    为什么要在jdk1.8中取消分段锁，有啥好处？  锁的粒度更小，其次，扩容的时候效率更高。 从整个segment扩容变为一个key的链表扩容。

4, newInstance() 和getClasses()
newInstance方法是调用了无参构造器。
getClasses()方法，是返回类定义公共的内部类，以及从父类或者接口继承来的内部类
 getDeclaredClasses()，返回类中定义的公共的，私有的，受保护的内部类。

 