1， == 和hashcode
    ==是比较的对象的内存地址。所以有时候就需要equals来进行比较。而hashcode则相当于对象的一个签名。

2， hashmap的底层
    数组（hash桶）加链表。
    transient HashMap.Node<K, V>[] table     +          Node<K,V> next;
    hashmap产生的死锁线程不安全问题？  多条线程并发时候，在resize的时候，会发生链表互相指向死锁的情况。
    但是在jdk8中采用了红黑树解决了这个问题。
    jdk8对hashmap的优化： 当链表的长度大于8的时候，就会转链表为红黑树。红黑树当然不会发生链表的循环引用情况。
    并且，红黑树的get（）方法的时间复杂度是O(log n),,远远小于链表的O(n)

3， concurrenthashmap的原理
    jdk1.7是segment分段锁，将hashmap的大数组，分为一个个的小数组。然后每个分段用reentrantlock锁。
    jdk1.8，放弃了segment，采用数组+链表+红黑树。
