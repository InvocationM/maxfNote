1，volitile：
    每条线程都有自己的工作内存，用volatile修饰的变量，修改后会强制将这个变量的最新值刷新进入主内存。
    并使其他线程的工作空间的变量值强制过期。

    主要作用是保证可见性和有序性。不能保证原子性。原子性用锁来解决。
2, jdk6以上对 synchronized的优化
    1，锁消除： 去掉那种不可能出现资源竞争的锁。比如
    2，锁粗话： 将锁的粒度变大。比如for中的锁，提取到for外部来。
    3，使用偏向锁和轻量级锁。
        jdk6为了减少获取锁和释放锁的开销，引入了偏向锁和轻量级锁。
        锁共有四种状态，级别从低到高分别是，无锁状态，偏向锁，轻量级锁，重量级锁。
        锁的级别会随着竞争情况逐渐升级，锁状态只能上升不能降级。

      a, 偏向锁
        背景：在大多数情况下，锁不仅不存在竞争的情况，而且锁总是由同一个线程获得。
        概念：核心思想就是锁会偏向于第一个获得他的线程，如果在接下来的执行过程中没有其他线程获取该锁，则持有偏向锁的线程永远不需要同步。
        目的：减少数据无竞争情况下的性能损耗。
      b, 轻量级锁
        