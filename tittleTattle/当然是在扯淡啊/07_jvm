
根据jvm规范，分为：类加载器，执行引擎，本地方法库，内存区域。

内存区域分为： 线程共享的： 方法区（永久代 又叫non-heap），存放类信息，常量，静态变量等等。
， 堆。  （jdk1.8，已经改方法区为元空间mataspace。）
            线程独享的： 寄存器，虚拟机栈，本地方法栈。

 为什么类加载器是线程安全的？
 因为一个类只加载一次，（相同的文件名，相同的类加载器加载。）并且，所调用的加载类的方法是线程安全的。Vector



 -------
 垃圾回收相关
 1，哪些对象需要回收？
    引用计数法：对每一个对象都进行引用标记。引用数为0的对象进行回收。缺点：无法解决循环引用问题。
    标记清除法：后面算法的基础。分为标记阶段和清除阶段。标记阶段就是通过根对象，
            标记所有能够从跟节点开始可以到达的对象。清除阶段，清除所有根节点不能到达的对象。缺点是：会产生空间碎片。
    复制算法：将内存分为两块。只使用其中的一块。垃圾回收时，将使用的那块内存中所有的存活对象都复制到未
            使用的那块，之后，清除使用内存的剩余对象。优点是效率高。缺点是内存只能使用一半。
    标记压缩算法：从标记清除算法开始，然后将所有使用的对象压缩到内存的一端，之后，清理边界外所有内存。优点：避免了内存碎片
    增量算法：垃圾收集线程和应用程序线程交替执行
    分代：将内存区，根据对象不同的特点，使用不同的垃圾收集算法。

 2，何时进行垃圾回收？
 3，怎么进行垃圾回收？


怎么评价一个垃圾收集器？
吞吐量 垃圾收集器负载 停顿时间 垃圾回收效率 反应时间 堆分配


----
Class.forName（） 和loadClass（） 区别：
前者进行了加载连接初始化。因为数据库驱动需要用到静态代码块中的DriverManager，所以必须进行初始化。
后者，只进行了加载，没有连接和初始化。
driverClass = this.getClass().getClassLoader().loadClass(driverClassName);
driverClass.getConstructor().newInstance();
先加载驱动的Class类型，然后用这个Class调用构造器，然后实例化。

