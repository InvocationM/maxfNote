
场景描述：
一个服务，从本地数据库get大量数据，然后保存到前置机的oracle数据库中。
dao层使用的hibernate框架。原本使用的是saveOrUpdate方法。 在保存55万数据前， 程序速度很快，但是55万数据后面，程序运行变得很慢，
保存一条数据需要七秒多。
经查询，服务器主机内存磁盘cpu等不是瓶颈。程序jvm也没有瓶颈。也没有死锁溢出啥的。
oracle数据库，连接数较大43个。自己服务三个。不知道这40个是啥。重启服务依然存在。
临时表空间，占用达到了百分之九十九点九九。修改变大后没有效果。
查询oracle的死锁。会出现一个瞬时态的死锁。一下出来，一下子又没了。直接杀掉，没有用。
打印程序运行时间，时间主要消耗在 saveOrUpdate方法。修改此方法为save方法，程序正常。
总结：
saveOrUpdate方法，会对调用对象的transite瞬时态进行判断。来决定是调用insert插入还是update更新。根据主键的生成策略，来对当前对象的主键和unsaved-value进行比照
假如当前对象没有被保存过，则这个unsaved-value和当前对象主键相同，调用insert方法。假如不同，则调用更新方法。

save方法，框架怎么判断到底是执行insert还是update，一般会根据主键进行查询，有数据是update没有数据就insert。
